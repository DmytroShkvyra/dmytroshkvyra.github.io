<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
	<title>TODO supply a title</title>
	<meta charset="windows-1251">
	<meta name="viewport" content="width=device-width">
	<!--script data-turbolinks-track="true" src="/js/walsh.js"></script>
	<link href="/styles/style.css" media="all" rel="stylesheet" /-->
	<script>


//var real = new Float32Array([0,0.4,0.4,1,1,1,0.3,0.7,0.6,0.5,0.9,0.8]);

function walsh(n, shift, step){
  walsh.prototype.this = this;
  this.n = (n !== undefined)? n: 32;
  this.shift = (shift !== undefined)? shift: 45;
  this.step = (step !== undefined)? step: 3;
  
  walsh.prototype.getWave = function(code){
    var codeArr = this.matrix[code];
    var lengthOfFFT = this.shift + 1 + codeArr.length*this.step*2;
    var res = new Array(lengthOfFFT).fill(0,0,lengthOfFFT);
    var walshKoefs = new Array(this.shift + 1 + codeArr.length*this.step).fill(0,0,this.shift + 1 + codeArr.length*this.step);
    for(var i= 0; i<codeArr.length; i++){
      var val = 0;
      if (codeArr[i] === 1) {
		res[this.shift + 1 + this.step*i*2] = 1
      }
      else if (codeArr[i] === -1) {
		res[this.shift + 1 + this.step*i*2+this.step] = 1
	 }
      walshKoefs[this.shift + 1 + this.step*i] = codeArr[i];
    }
    this.spectrWalsh[code] = walshKoefs;
    return new Float32Array(res);
  };
 
walsh.prototype.test = function(){
this.first = new Array(16).fill(0,0,16)
for(var i=0; i<this.first.length/2; i++){
this.first[i*2]=1;
this.first[i*2+1]=2;
}
}
 
  walsh.prototype.negativate = function(matrix){
    res = this.create2DArr(matrix.length);
    for(var n=0; n<matrix.length; n++){
      for (var m=0; m<matrix[n].length; m++){
        res[n][m] = matrix[n][m]*-1;
      }
    }
    return res;  
  };
  
  walsh.prototype.create2DArr = function(n){
    var res = [];
    for(var i=0; i<n; i++){
      res.push([]);
      for(var j=0; j<n; j++){
        res[i].push(0);
      }
    }
    return res;
  };
  
  walsh.prototype.createAdamar = function(matrix){
    var dimension = matrix.length;
    var newDimesion = dimension*2;
    var resMatrix = this.create2DArr(newDimesion);
    for(var N=0; N<2; N++){
      for(var M=0; M<2; M++){
        var tmpMatrix = matrix;
        if(N>0 && M>0) {
          tmpMatrix = this.negativate(matrix);
        }
        for(var n=0; n<dimension; n++){
          for(var m=0; m<dimension; m++){
            resMatrix[N*dimension+n][M*dimension+m] = tmpMatrix[n][m];
          }
        }
      }
    }
    return (resMatrix.length<this.n)? this.createAdamar(resMatrix): resMatrix;
  };
  
  walsh.prototype.decode = function(inputarr){
    var res = {};
	var mags = new Array(this.matrix.length).fill(0,0,this.matrix.length);
    for(var i=1; i<this.matrix.length; i++){
      var mag = 0;
	  var avg = 0;
	  var c = 0;
      //Average magnitude
	  /*for(c=0; c<this.spectrWalsh[i].length; c++){
        if(this.spectrWalsh[i][c] !== 0){
			avg += inputarr[c];
		}
      }
	  avg /= c;*/

      for(var j=0; j<this.matrix.length; j++){
        var positive = inputarr[this.shift + 1 + this.step*i*2];
		var negative = inputarr[this.shift + 1 + this.step*i*2+this.step];
		var bit = positive-negative;
		mag += this.matrix[i][j]*bit;
        //mag += this.spectrWalsh[i][j]*(inputarr[j]-avg);
      }
	  mags[i] = mag;
    }

	var diff = 0;
	var avg = 0;
	for(var j=1; j<mags.length; j++){
	  avg += mags[j];
    }
	avg /= (mags.length - 1); 
	for(var j=1; j<mags.length; j++){
	  diff += Math.pow(mags[j]-avg, 2);
    }
	diff /= (mags.length - 1);
	this.sigma = Math.sqrt(diff);
	for(var j=1; j<mags.length; j++){
		if(mags[j]>0){
			res[j] = (mags[j]-avg)/this.sigma;
		} else {
			res[j] = 0;
		}
	  
    }
	
    return res;
  };

  this.encodeMatrix = this.create2DArr(this.n -1 );
  for(var i=0; i<this.encodeMatrix.length; i++){
    var c = 1;
	for(var j=0; j<this.encodeMatrix.length; j++){
		if(i==j){
			this.encodeMatrix[j][i] = 0;
		} else {
		    this.encodeMatrix[j][i] = c++;
		} 
	}
  
  }  

  // Encode sequece of sym to prevent repeating
  walsh.prototype.encode = function(outputarr){
	var res = [];
	this.perv = 0;
	for(var i=0; i<outputarr.length; i++){
		var sym = outputarr[i]+1;
        if(sym > this.encodeMatrix.length - 1) throw ("There have not to be value more than " + (this.encodeMatrix.length - 2))
	    if(i==0){
				res.push(sym);
				this.perv = sym;			
			/*if(outputarr[i]<this.encodeMatrix.length-3) {
				res.push(sym +2);
				this.perv = sym + 2;
			}
			else {
				res.push((sym+1) - (this.encodeMatrix.length-1));
                this.perv = ((sym+1) - (this.encodeMatrix.length-1));
			}*/
		}
		for(var j=0; j<this.encodeMatrix.length; j++){
			if(sym == this.encodeMatrix[j][this.perv]){
				this.perv = j;
				res.push(j);
				break;
			}
		}
	}
    return res;
  }

  walsh.prototype.decodeSequenceTest = function(arr){
	var res = [];
	function addToRes(sym){
		res.push(sym);
	}
	for(var i=0; i<arr.length; i++){
		this.decodeSequence(arr[i], addToRes);
	}
	return res;
  }
  
  walsh.prototype.decodeSequence = function(sym, detected){
    if(this.first === undefined){
		this.first = sym;
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, 50 );
		return;
	} else if(this.first === sym){
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, 50 );
		return;
	} else {
		var res = this.encodeMatrix[sym][this.first];
		this.first = sym;
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, 50 );
		if(detected !== undefined) detected(res-1);
	}
  }  

  walsh.prototype.clearSym = function(){
	if(walsh.prototype.this.timerId !== undefined) clearTimeout(walsh.prototype.this.timerId)
	walsh.prototype.this.first = undefined;  
  }
 
	
 
  this.matrix = this.createAdamar([[1,1],[1,-1]]);
 
  this.waves = new Array(this.n);
  this.spectrWalsh = new Array(this.n);
  for(var i=0; i<this.waves.length; i++){
    this.waves[i] = this.getWave(i);
  }
  
}

var w = new walsh();
var audioContext = new AudioContext();


function toggle() {     $("button").toggle();
                  }
function play() {


rate = audioContext.sampleRate; 
var chars = document.getElementById("sym").value.split('');
var codes = [];
for(var i=0; i<chars.length;i++){
	codes.push(chars[i].charCodeAt(0)-65);
} 

var syms = w.encode(codes);
var waves = [];

    var fft = rate/parseInt(document.getElementById("f").value)|0;
    var fftarr = ((new Array(fft)).fill(0.0,0,fft+1).fill(1,1,50));
    //var real = new Float32Array(fftarr);
 
  
  for(var i=0; i<syms.length; i++){
    var real = w.getWave(parseInt(syms[i]));
    var imag = new Float32Array(real.length);
    var hornTable = audioContext.createPeriodicWave(real, imag); 
    waves.push(hornTable);	
  }

    var i = 0;
	var osc; 
	var timerId = setTimeout(function run() {
	    if (waves.length === i) {
			clearTimeout(timerId);
			osc.stop();
			osc.disconnect();
			return;
	    } else if(i != 0) {
			osc.stop();
			osc.disconnect();
		}
        osc = audioContext.createOscillator();
        osc.frequency.value = parseFloat(document.getElementById("f").value);		
        osc.setPeriodicWave(waves[i]);               
		osc.connect(audioContext.destination);
        osc.start();	    
	    timerId = setTimeout(run, 200 );
	    i++;
	}, 200 ) ;
  

}
function stop() {
  osc.stop();
  osc.disconnect();
}

// Stereo
var channels = 1;
// Create an empty two second stereo buffer at the
// sample rate of the AudioContext
var audioCtx = new AudioContext();
var frameCount = audioCtx.sampleRate * 2.0;

var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);
function click1() {
  // Fill the buffer with white noise;
  //just random values between -1.0 and 1.0
  for (var channel = 0; channel < channels; channel++) {
   // This gives us the actual array that contains the data
   var nowBuffering = myArrayBuffer.getChannelData(channel);
   for (var i = 0; i < frameCount; i++) {
     // Math.random() is in [0; 1.0]
     // audio needs to be in [-1.0; 1.0]
     nowBuffering[i] = Math.random() * 2 - 1;
   }
  }

  // Get an AudioBufferSourceNode.
  // This is the AudioNode to use when we want to play an AudioBuffer
  var source = audioCtx.createBufferSource();
  // set the buffer in the AudioBufferSourceNode
  source.buffer = myArrayBuffer;
  // connect the AudioBufferSourceNode to the
  // destination so we can hear the sound
  source.connect(audioCtx.destination);
  // start the source playing
  source.start();
}
	    
	</script>    
    </head>
    <body>
	<div>TODO write content</div>
	<input value="21.533203125" id="f"/>
	<input value="ABCDEFGHJLMNOP" id="sym"/>
	<input type="button" value="Play" onclick="play();"/>
	<!--input type="button" value="Stop" onclick="stop();"/-->
  <input type="button" value="PlayWave" onclick="click1();"/>
  <a href="https://dmytroshkvyra.github.io/">Back</a>
    </body>
</html>
