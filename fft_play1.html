<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
	<title>TODO supply a title</title>
	<meta charset="windows-1251">
	<meta name="viewport" content="width=device-width">
	<!--script data-turbolinks-track="true" src="/js/walsh.js"></script>
	<link href="/styles/style.css" media="all" rel="stylesheet" /-->
	<script>


function walsh(n, shift, step, dimension,  tresholdTimeout){
  walsh.prototype.this = this;
  this.n = (n !== undefined)? n: 64;
  this.shift = (shift !== undefined)? shift: 45;
  this.step = (step !== undefined)? step: 3;
  this.dimension = (dimension !== undefined)? dimension : 1;
  this.tresholdTimeout = (tresholdTimeout !== undefined)? tresholdTimeout: 100;
  
  walsh.prototype.getCodes = function(code){
    var maxCodeLength = ((Math.pow(this.n/this.dimension, this.dimension)-1).toString(2)).length;
    var dimesionLength = maxCodeLength/this.dimension|0;
    var codeBin = code.toString(2);
    if(codeBin.length < maxCodeLength){
		codeBin = '0'.repeat(maxCodeLength - codeBin.length) + codeBin;
	}
    var res = [];
    for(var i=0; i<this.dimension; i++){
		res.push(parseInt(codeBin.substr(i*dimesionLength, dimesionLength), 2));
	}
    
	return res;
  }	
  
  walsh.prototype.getWave = function(code){
    var codeArr = this.matrix[code];
    var lengthOfFFT = this.shift + 1 + codeArr.length*this.step*2;
    var res = new Array(lengthOfFFT).fill(0,0,lengthOfFFT);
    
    for(var i= 0; i<codeArr.length; i++){
      var val = 0;
      if (codeArr[i] > 0) {
		res[this.shift + 1 + this.step*i*2] = 1
      }
      else if (codeArr[i] < 0) {
		res[this.shift + 1 + this.step*i*2+this.step] = 1
	  }
    }
    return new Float32Array(res);
  };
  
  walsh.prototype.negativate = function(matrix){
    res = this.create2DArr(matrix.length);
    for(var n=0; n<matrix.length; n++){
      for (var m=0; m<matrix[n].length; m++){
        res[n][m] = matrix[n][m]*-1;
      }
    }
    return res;  
  };
  
  walsh.prototype.create2DArr = function(n){
    var res = [];
    for(var i=0; i<n; i++){
      res.push([]);
      for(var j=0; j<n; j++){
        res[i].push(0);
      }
    }
    return res;
  };
  
  walsh.prototype.createAdamar = function(matrix){
    var dimension = matrix.length;
    var newDimesion = dimension*2;
    var resMatrix = this.create2DArr(newDimesion);
    for(var N=0; N<2; N++){
      for(var M=0; M<2; M++){
        var tmpMatrix = matrix;
        if(N>0 && M>0) {
          tmpMatrix = this.negativate(matrix);
        }
        for(var n=0; n<dimension; n++){
          for(var m=0; m<dimension; m++){
            resMatrix[N*dimension+n][M*dimension+m] = tmpMatrix[n][m];
          }
        }
      }
    }
    return (resMatrix.length<this.n)? this.createAdamar(resMatrix): resMatrix;
  };
  
  walsh.prototype.decode = function(inputarr){
    var res = {};
	var mags = new Array(this.matrix.length).fill(0,0,this.matrix.length);
    for(var i=0; i<this.matrix.length; i++){
      var mag = 0;
      for(var j=0; j<this.matrix.length; j++){
        var positive = inputarr[this.shift + 1 + this.step*j*2];
		var negative = inputarr[this.shift + 1 + this.step*j*2+this.step];
		var bit = positive-negative;
		mag += this.matrix[i][j]*bit;
      }
	  mags[i] = (mag >0 )? mag : 0;
    }

	var diff = 0;
	var avg = 0;
	var c = 0;
	for(var j=0; j<mags.length; j++){
		if(mags[j]>0){
			avg += mags[j];
			c++;
		}
    }
	avg /= c; 
	for(var j=0; j<mags.length; j++){
		if(mags[j]>0){
			diff += Math.pow(mags[j]-avg, 2);
		}
    }
	diff /= c;
	this.sigma = Math.sqrt(diff);
	for(var j=0; j<mags.length; j++){
		res[j] = (mags[j]> avg)? (mags[j]-avg)/this.sigma : 0;  
    }
	
    return res;
  };

  this.encodeMatrix = this.create2DArr(Math.pow(this.n/this.dimension, this.dimension));
  for(var i=0; i<this.encodeMatrix.length; i++){
    var c = 1;
	for(var j=0; j<this.encodeMatrix.length; j++){
		if(i==j){
			this.encodeMatrix[j][i] = 0;
		} else {
		    this.encodeMatrix[j][i] = c++;
		} 
	}
  
  }   

  // Encode sequece of sym to prevent repeating
  walsh.prototype.encode = function(outputarr){
	var res = [];
	this.perv = 0;
	for(var i=0; i<outputarr.length; i++){
		var sym = outputarr[i]+1;
        if(sym > this.encodeMatrix.length) throw ("There have not to be value more than " + (this.encodeMatrix.length - 1))
	    if(i==0){
				res.push(sym);
				this.perv = sym;			
		}
		for(var j=0; j<this.encodeMatrix.length; j++){
			if(sym == this.encodeMatrix[j][this.perv]){
				this.perv = j;
				res.push(j);
				break;
			}
		}
	}
    return res;
  }

  walsh.prototype.decodeSequenceTest = function(arr){
	var res = [];
	function addToRes(sym){
		res.push(sym);
	}
	for(var i=0; i<arr.length; i++){
		this.decodeSequence(arr[i], addToRes);
	}
	return res;
  }
  
  walsh.prototype.decodeSequence = function(sym, detected){
    if(this.first === undefined){
		this.first = sym;
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, this.tresholdTimeout );
		return;
	} else if(this.first === sym){
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, this.tresholdTimeout );
		return;
	} else {
        var res;
		try{
			res = this.encodeMatrix[sym][this.first];
		} catch (err) {
			this.first = sym;
			if(this.timerId !== undefined) clearTimeout(this.timerId)
			this.timerId = setTimeout(this.clearSym, this.tresholdTimeout );
			return;
		}
		this.first = sym;
		if(this.timerId !== undefined) clearTimeout(this.timerId)
		this.timerId = setTimeout(this.clearSym, this.tresholdTimeout );
		if(detected !== undefined) detected(res-1);
	}
  }  

  walsh.prototype.clearSym = function(){
	if(walsh.prototype.this.timerId !== undefined) clearTimeout(walsh.prototype.this.timerId)
	walsh.prototype.this.first = undefined;  
  }
  
  this.matrix = this.createAdamar([[1,1],[1,-1]]);
 
  this.waves = new Array(this.n);
  for(var i=0; i<this.waves.length; i++){
    this.waves[i] = this.getWave(i);
  }
  
}
var w = new walsh();
var audioContext = new AudioContext();


function toggle() {     $("button").toggle();
                  }
function play() {


rate = audioContext.sampleRate; 
var chars = document.getElementById("sym").value.split('');
var codes = [];
for(var i=0; i<chars.length;i++){
	codes.push(chars[i].charCodeAt(0)-65);
} 

var syms = w.encode(codes);
var waves = [];

    var fft = rate/parseInt(document.getElementById("f").value)|0;
    var fftarr = ((new Array(fft)).fill(0.0,0,fft+1).fill(1,1,50));
    //var real = new Float32Array(fftarr);
 
  
  for(var i=0; i<syms.length; i++){
    var real = w.getWave(parseInt(syms[i]));
    var imag = new Float32Array(real.length);
    var hornTable = audioContext.createPeriodicWave(real, imag); 
    waves.push(hornTable);	
  }

    var i = 0;
	var osc; 
	var timerId = setTimeout(function run() {
	    if (waves.length === i) {
			clearTimeout(timerId);
			osc.stop();
			osc.disconnect();
			return;
	    } else if(i != 0) {
			osc.stop();
			osc.disconnect();
		}
        osc = audioContext.createOscillator();
        osc.frequency.value = parseFloat(document.getElementById("f").value);		
        osc.setPeriodicWave(waves[i]);               
		osc.connect(audioContext.destination);
        osc.start();	    
	    timerId = setTimeout(run, 100 );
	    i++;
	}, 100 ) ;
  

}
function stop() {
  osc.stop();
  osc.disconnect();
}

// Stereo
var channels = 1;
// Create an empty two second stereo buffer at the
// sample rate of the AudioContext
var audioCtx = new AudioContext();
var frameCount = audioCtx.sampleRate * 2.0;

var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);
function click1() {
  var control = document.getElementById("sym");
  for(var i=0; i<62; i++){
	control.value = control.value + String.fromCharCode(i+65)

  }

 
  // Fill the buffer with white noise;
  //just random values between -1.0 and 1.0
  for (var channel = 0; channel < channels; channel++) {
   // This gives us the actual array that contains the data
   var nowBuffering = myArrayBuffer.getChannelData(channel);
   for (var i = 0; i < frameCount; i++) {
     // Math.random() is in [0; 1.0]
     // audio needs to be in [-1.0; 1.0]
     nowBuffering[i] = Math.random() * 2 - 1;
   }
  }

  // Get an AudioBufferSourceNode.
  // This is the AudioNode to use when we want to play an AudioBuffer
  var source = audioCtx.createBufferSource();
  // set the buffer in the AudioBufferSourceNode
  source.buffer = myArrayBuffer;
  // connect the AudioBufferSourceNode to the
  // destination so we can hear the sound
  source.connect(audioCtx.destination);
  // start the source playing
  source.start();
}
	    
	</script>    
    </head>
    <body>
	<div>TODO write content</div>
	<input value="21.533203125" id="f"/>
	<input value="ABCDEFGHJLMNOP" id="sym"/>
	<input type="button" value="Play" onclick="play();"/>
	<!--input type="button" value="Stop" onclick="stop();"/-->
  <input type="button" value="PlayWave" onclick="click1();"/>
  <a href="https://dmytroshkvyra.github.io/">Back</a>
    </body>
</html>
